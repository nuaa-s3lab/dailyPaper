(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{650:function(t,a,s){t.exports=s.p+"assets/img/1.8c9e729a.png"},651:function(t,a,s){t.exports=s.p+"assets/img/2.8ba68f24.png"},652:function(t,a,s){t.exports=s.p+"assets/img/3.22be1823.png"},653:function(t,a,s){t.exports=s.p+"assets/img/4.d6200aa5.png"},654:function(t,a,s){t.exports=s.p+"assets/img/5.575c5bd7.png"},689:function(t,a,s){"use strict";s.r(a);var e=s(6),i=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("大家好，今天我为大家带来了来自 "),e("em",[t._v("ACSAC 2019")]),t._v(" 的《DR.SGX: Automated and Adjustable Side-Channel Protection for SGX using Data Location Randomization》。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(650),alt:""}})]),t._v(" "),e("p",[t._v("这篇文章主要关注由数据访问监视引起的信息泄露问题，因为最近很多工作都利用数据访问攻击 SGX enclaves。现有的随机化方案（例如 SGX-Shield）通过已知的结构（函数或块）随机化代码，没有解决数据随机化的问题，无法阻止利用数据访问的攻击。而且现在的 C/C++ 代码分析和指针跟踪无法处理数据。")]),t._v(" "),e("p",[t._v("作者们希望提供无需开发人员帮助就可以提供侧信道保护的自动化工具，并在安全和性能之间实现可调整的权衡。作者们的主要思想是以精细的粒度将 enclave 内存中的所有数据位置随机化。Enclave 生成一个秘密的随机密钥，并根据该密钥计算每个内存地址的排列。这样可以让对手无论从哪个信道观察，都无法将观察到的（置换的）内存地址映射到实际地址。作者将他们的方法称为语义不可知的数据随机化（semantic-agnostic data randomization）。而在实现 enclave 中的数据随机化有很多挑战。")]),t._v(" "),e("ol",[e("li",[t._v("如何在对抗监视（adversarial monitoring）下实现安全有效的计算。因为一旦对手能够从地址排列过程中获得信息，就可以恢复随机化。")]),t._v(" "),e("li",[t._v("效率也是一个挑战。为每一次数据访问计算一个排列代价昂贵且开销高昂。")]),t._v(" "),e("li",[t._v("重复的内存访问会导致信息泄露。单独的访问实际上已经被对手隐藏了，但是重复放回会导致置换的地址关联和泄露。")])]),t._v(" "),e("p",[t._v("文章解决了这个挑战，并实现了一个基于编译器的工具 DR.SGX（"),e("strong",[t._v("D")]),t._v("ata Location "),e("strong",[t._v("R")]),t._v("andomization for "),e("strong",[t._v("SGX")]),t._v("），它在编译时插桩 enclave 代码，以便在运行时将用于存储 enclave 数据（在堆中）的所有内存位置按缓存行粒度排列。作者们使用小域（small domain）加密并利用 CPU 的硬件加速单元（AES-NI）安全地实现了置换。为了解决相关性攻击，DR.SGX 允许定期重新随机化 enclave 数据：更积极的重新随机化率更好地隐藏了重复的内存访问模式，但是代价是运行时开销更高。作者们的贡献如下：")]),t._v(" "),e("ul",[e("li",[t._v("提出了一种被称为语义不可知数据随机化的方法以防御对 SGX 的侧信道攻击。")]),t._v(" "),e("li",[t._v("设计了 DR.SGX，可以插桩代码，以缓存行的粒度对安全区的数据存储位置进行置换，并反复对其随机化。")]),t._v(" "),e("li",[t._v("评估了系统的性能，分析可能的泄露，并展示如何保护以前的攻击目标。")])]),t._v(" "),e("details",{staticClass:"custom-block details"},[e("summary",[t._v("攻击模型")]),t._v(" "),e("p",[t._v("攻击者的目标是通过缓存侧信道攻击（包括 CPU 内部缓存，如转换后备缓冲区(translation look-aside buffer)和/或页侧信道攻击）从隔离的执行环境（enclave）中提取敏感信息。敏感信息并不局限于加密密钥，还有例如云端处理隐私数据时等情况。")]),t._v(" "),e("p",[t._v("作者们假设攻击者可以自由配置和修改系统的所有软件，包括操作系统等特权软件。攻击者页知道 enclave 的初始内存布局，即其中的代码和初始数据。作者们还假设攻击者可以任意进攻 enclave。但是对手无法直接访问 enclave 的内存，无法访问处理器内部的状态，如果发生中断，状态会安全地存储在隔离的内存区域中。")]),t._v(" "),e("p",[t._v("作者们还假设攻击者可以通过侧信道观察到所有的 enclave 内存访问。但是无法提取比访问缓存行更细粒度的信息（比如缓存行内部的偏移）。")])]),t._v(" "),e("p",[t._v("DR.SGX 的核心思想是混淆内存位置和数据元素之间的联系：数据元素存储在内存的随机位置，攻击者不能推断出从观察到的内存访问位置访问了哪个数据元素。攻击者不再知道"),e("strong",[t._v("哪个")]),t._v("数据元素被访问，而是只知道"),e("strong",[t._v("某个")]),t._v("数据元素被访问。")]),t._v(" "),e("p",[t._v("DR.SGX 将 enclave 内存分割成小块并随机重排序，从进攻者的角度看导致了不可预测的内存布局。例如下图中的 AES 加密使用的 S 盒。尽管对手可能从侧信道观察到某些缓存块，但是粒度不够精细。作者们通过对对应内存地址和缓存行的频繁更改阻止进攻者将观察到的访问（缓存或页面调度）链接到 S 盒的能力，这是 DR.SGX 的核心想法。")]),t._v(" "),e("img",{staticStyle:{zoom:"67%"},attrs:{src:s(651)}}),t._v(" "),e("p",[t._v("作者们认为在实现的时候挑战如下。")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("语义空缺（gap）")]),t._v(" 没有开发人员协助难以通过数据随机化提供针对 SGX 的侧信道保护（因为 SGX SDK 只支持 C/C++）。")]),t._v(" "),e("li",[e("strong",[t._v("重随机化")]),t._v(" 仅对程序的内存布局进行一次随机化以防止攻击者知道哪些数据已被访问是不够的。对手可以基于各种信息确定内存位置和数据对象的关系。")]),t._v(" "),e("li",[e("strong",[t._v("攻击者观察下的（重）随机化")]),t._v(" 攻击者可以观察到被攻击区域所有与内存相关的动作，包括在初始数据随机化和内存布局重新随机化期间所需的操作。")])]),t._v(" "),e("p",[t._v("DR.SGX 通过对所有程序的数据进行细粒度随机化并在整个程序运行时连续重新随机化数据解决上述挑战。它的设计如下图所示。攻击者无法直接访问某个 enclave 的主内存，但是可以通过缓存和分页侧信道间接观察内存访问。攻击者无法观察到存储在寄存器和/或特殊的函数单元（例如 AES 引擎）中的 CPU 内部状态。")]),t._v(" "),e("img",{staticStyle:{zoom:"67%"},attrs:{src:s(652)}}),t._v(" "),e("p",[t._v("DR.SGX 的设计思想主要是两步。")]),t._v(" "),e("ol",[e("li",[e("strong",[t._v("内存访问插桩")]),t._v(" DR.SGX 对缓存行粒度随机化有两个原因。\n"),e("ol",[e("li",[t._v("更细粒度的随机化没有带来任何安全优势；")]),t._v(" "),e("li",[t._v("由于语义空缺，以数据结构感知方式进行随机化不切实际；"),e("br"),t._v("\n他们通过编译器报纸随机化可以检测所有内存访问。程序代码可以确定原始的非随机布局中数据的内存位置（即地址）。然后再执行访问前先计算该地址的随机位置，然后在新的随机位置中访问数据。他们还引入了一个置换缓冲区加快访问速度。")])])]),t._v(" "),e("li",[e("strong",[t._v("初始随机化")]),t._v(" 他们通过将一组数据加载到 CPU 寄存器中并随机化以阻止对手观察初始随机化的过程。但这种数据能载入的数据有限。他们还是要了非时态写（non-temporal write）的方法逃避 CPU 缓存，让对手无法观察到初始随机化过程中写的内存地址。")])]),t._v(" "),e("p",[t._v("DR.SGX 由六个关键部分构成。")]),t._v(" "),e("ol",[e("li",[t._v("内存访问插桩模块")]),t._v(" "),e("li",[t._v("随机置换模块")]),t._v(" "),e("li",[t._v("初始随机化模块")]),t._v(" "),e("li",[t._v("栈随机化模块")]),t._v(" "),e("li",[t._v("置换缓冲区模块")]),t._v(" "),e("li",[t._v("重随机化模块")])]),t._v(" "),e("p",[t._v("而后的实验评估显示了 DR.SGX 的开销。DR.SGX 在不开启重新随机化时的开销大约是普通情况的 4.36 倍，而开启了随机化后的开销约为 5 倍到 11 倍，比用完整的 ORAM 方案（"),e("RouterLink",{attrs:{to:"/2021/0112.html"}},[t._v("Obfuscuro")]),t._v("）快了一个数量级。而且他们的方案只处理了数据。作者们认为 DR.SGX 是 OBFUSCURO 的推广，当重随机化参数 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("w")]),e("mo",[t._v("=")]),e("mn",[t._v("1")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("w=1")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02691em"}},[t._v("w")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2777777777777778em"}}),e("span",{staticClass:"mrel"},[t._v("=")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2777777777777778em"}})]),e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.64444em","vertical-align":"0em"}}),e("span",{staticClass:"mord"},[t._v("1")])])])])]),t._v(" 时，DR.SGX 实现了 ORAM，代价高昂；如果 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("w")]),e("mo",[t._v("=")]),e("mi",{attrs:{mathvariant:"normal"}},[t._v("∞")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("w=\\infty")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02691em"}},[t._v("w")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2777777777777778em"}}),e("span",{staticClass:"mrel"},[t._v("=")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2777777777777778em"}})]),e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),e("span",{staticClass:"mord"},[t._v("∞")])])])])]),t._v(" 时，DR.SGX 只随机化一个 enclave 的初始布局，这对某些 enclave 来说可能已经足够了。")],1),t._v(" "),e("img",{staticStyle:{zoom:"67%"},attrs:{src:s(653)}}),t._v(" "),e("p",[t._v("而后作者们讨论了 DR.SGX 的安全性，包括在轨迹中寻找跟踪位置、推断秘密 enclave 中的数据等。")]),t._v(" "),e("img",{staticStyle:{zoom:"80%"},attrs:{src:s(654)}}),t._v(" "),e("p",[t._v("作者们的安全评价表明，DR.SGX 提供的保护取决于目标 enclave。在某些 enclave 上，可预测的数据访问模式（例如初始化程序）之后很快会被基于秘密的数据访问跟踪，它们需要积极地重新随机化以防止泄露，从而会产生更好的开销。而在较差的情况下，DR.SGX 可以在每次内存访问后重新随机化内存以防止任何泄露，有效地起到了 ORAM 实现的作用。")]),t._v(" "),e("ul",[e("li",[t._v("PDF: "),e("a",{attrs:{href:"https://arxiv.org/pdf/1709.09917",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://arxiv.org/pdf/1709.09917"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=i.exports}}]);